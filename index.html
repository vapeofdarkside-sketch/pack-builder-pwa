<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pack Builder (PWA)</title>
<link rel="manifest" href="manifest.webmanifest" />
<meta name="theme-color" content="#0e1117" />
<style>
  :root{
    --bg:#0e1117; --card:#161b22; --field:#0d1117;
    --text:#fff; --muted:rgba(255,255,255,.75);
    --green:#4caf50; --yellow:#ffc107; --red:#f44336;
    --accent:#7c5cff;
  }
  *{box-sizing:border-box;}
  body{background:var(--bg);color:var(--text);font-family:Arial,sans-serif;margin:0;padding:18px;}
  h1{margin:0 0 14px 0;font-size:22px;}
  h3{margin:0 0 10px 0;}
  .card{background:var(--card);padding:14px;border-radius:12px;margin-bottom:14px;}
  .row{display:flex;gap:12px;flex-wrap:wrap;}
  .col{flex:1;min-width:160px;}
  label{display:block;margin-top:8px;margin-bottom:6px;font-size:13px;opacity:.9;}
  input,select{
    width:100%;padding:10px;border-radius:10px;border:none;font-size:16px;
    background:var(--field);color:var(--text);
    outline:none;
  }
  input:disabled{opacity:.9;}
  table{width:100%;border-collapse:collapse;}
  td{padding:6px 0;font-size:14px;}
  td:last-child{text-align:right;}
  .green{color:var(--green);} .yellow{color:var(--yellow);} .red{color:var(--red);}
  .small{font-size:12px;opacity:.82;margin-top:8px;line-height:1.35;}
  .hidden{display:none;}

  /* Battery Button */
  .batteryBtnWrap{margin-top:14px;display:flex;justify-content:center;}
  .batteryBtn{
    position:relative;width:270px;height:76px;border-radius:18px;
    background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
    border:1px solid rgba(255,255,255,.10);
    overflow:hidden;cursor:pointer;user-select:none;
    box-shadow:0 0 0 1px rgba(124,92,255,.18) inset;
  }
  .batteryBtn::before{
    content:"";position:absolute;right:-10px;top:24px;width:14px;height:26px;border-radius:6px;
    background:rgba(255,255,255,.16);border:1px solid rgba(255,255,255,.10);
  }
  .batteryFill{position:absolute;left:0;top:0;bottom:0;width:0%;
    background:linear-gradient(90deg, rgba(124,92,255,.85), rgba(124,92,255,.30));
  }
  .batteryContent{
    position:relative;z-index:2;height:100%;
    display:flex;align-items:center;justify-content:space-between;
    padding:0 14px;gap:10px;
  }
  .batteryTitle{font-weight:800;font-size:14px;}
  .batterySub{font-size:12px;opacity:.78;margin-top:2px;}
  .batteryRight{text-align:right;font-variant-numeric:tabular-nums;}
  .batteryPct{font-weight:900;font-size:16px;}
  .batteryState{font-size:12px;opacity:.75;margin-top:2px;}
  .batteryBtn.disabled{cursor:default;opacity:.92;}

  /* Layout Page */
  .topbar{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px;}
  .btn{
    border:none;border-radius:10px;padding:10px 12px;
    background:rgba(255,255,255,.06);color:var(--text);
    font-weight:800;cursor:pointer;
  }
  .btn.primary{background:rgba(124,92,255,.20);border:1px solid rgba(124,92,255,.55);}
  .seg{display:flex;gap:10px;flex-wrap:wrap;}
  .seg .btn{min-width:110px;}

  canvas{
    width:100%;
    height:auto;
    border-radius:12px;
    background:#0b0b0c;
    box-shadow:0 0 0 1px rgba(255,255,255,.06) inset;
  }

  .pill{
    display:inline-block;
    padding:4px 8px;
    border-radius:999px;
    background:rgba(124,92,255,.18);
    border:1px solid rgba(124,92,255,.35);
    font-size:12px;
    font-weight:700;
  }
</style>
</head>
<body>

<!-- PAGE 1 -->
<div id="pageCalc">
  <h1>Pack Builder (PWA)</h1>

  <div class="card">
    <h3>Zelle auswählen</h3>

    <label>Hersteller / Modell</label>
    <select id="cellModel"></select>

    <div class="row">
      <div class="col"><label>Format</label><input id="format" disabled></div>
      <div class="col"><label>Kapazität (mAh)</label><input id="capacity" disabled></div>
    </div>

    <div class="row">
      <div class="col"><label>Max. Dauerstrom (A)</label><input id="maxA" disabled></div>
      <div class="col"><label>Nominalspannung (V)</label><input id="nomV" disabled></div>
    </div>

    <div class="row">
      <div class="col"><label>Vollspannung (V)</label><input id="fullV" disabled></div>
    </div>

    <div class="small" id="cellNote"></div>
  </div>

  <div class="card">
    <h3>Pack Konfiguration</h3>
    <div class="row">
      <div class="col">
        <label>Serien (S) — max 12</label>
        <input id="series" type="text" value="3" inputmode="numeric" pattern="[0-9]*" autocomplete="off">
      </div>
      <div class="col">
        <label>Parallel (P) — max 20</label>
        <input id="parallel" type="text" value="2" inputmode="numeric" pattern="[0-9]*" autocomplete="off">
      </div>
    </div>
    <div class="small">Große Packs werden im Layout automatisch passend skaliert.</div>
  </div>

  <div class="card">
    <h3>Zellen Info</h3>
    <table id="cellInfo"></table>
  </div>

  <div class="card">
    <h3>Pack Info</h3>
    <table id="packInfo"></table>

    <div class="batteryBtnWrap">
      <div id="packBtn" class="batteryBtn" title="Pack konfigurieren">
        <div id="packBtnFill" class="batteryFill"></div>
        <div class="batteryContent">
          <div>
            <div class="batteryTitle">Pack konfigurieren</div>
            <div id="packBtnText" class="batterySub">Tippen zum Laden & Layout öffnen</div>
          </div>
          <div class="batteryRight">
            <div id="packBtnPct" class="batteryPct">0%</div>
            <div id="packBtnState" class="batteryState">bereit</div>
          </div>
        </div>
      </div>
    </div>

  </div>

  <div class="small">
    <span class="pill">Hinweis</span>
    Für echte Packs immer BMS + Sicherung + Isolation verwenden.
  </div>
</div>

<!-- PAGE 2 -->
<div id="pageLayout" class="hidden">
  <div class="topbar">
    <button id="backBtn" class="btn">← Zurück</button>
    <div class="seg">
      <button id="topBtn" class="btn primary">Top</button>
      <button id="bottomBtn" class="btn">Bottom</button>
    </div>
  </div>

  <div class="card">
    <h3>Layout Einstellungen</h3>

    <div class="row">
      <div class="col">
        <label>Nickelbreite (mm)</label>
        <input id="nickelMm" type="number" min="4" max="30" step="0.5" value="8">
      </div>
      <div class="col">
        <label>Zell-Abstand (mm)</label>
        <input id="gapMm" type="number" min="0" max="5" step="0.1" value="0.6">
      </div>
    </div>

    <div class="row" style="margin-top:10px;">
      <div class="col"><button id="exportSvgBtn" class="btn primary" type="button">Export SVG (1:1)</button></div>
      <div class="col"><button id="threeBtn" class="btn" type="button">3D Ansicht</button></div>
    </div>
  </div>

  <div class="card">
    <canvas id="cv"></canvas>
  </div>

  <div id="threeWrap" class="card hidden">
    <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;">
      <h3 style="margin:0;">3D Ansicht</h3>
      <button id="threeClose" class="btn" type="button">Schließen</button>
    </div>
    <div id="threeContainer" style="width:100%;height:420px;border-radius:12px;overflow:hidden;background:#0b0b0c;margin-top:10px;"></div>
    <div class="small">Drehen: Touch/Drag. Zoomen: Pinch.</div>
  </div>
</div>

<!-- Three.js -->
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

<script>
// build: 2026-02-08-auto-layout-12s-p20-rowwise-series

const CELLS = [
  { id:"s35e",  name:"Samsung INR18650-35E",            format:"18650", mAh:3500, maxA:8,  nomV:3.6, fullV:4.2, note:"Hohe Kapazität, moderater Strom." },
  { id:"vtc5a", name:"Sony/Murata Konion US18650VTC5A", format:"18650", mAh:2600, maxA:25, nomV:3.6, fullV:4.2, note:"Sehr hochstromfähig." },
  { id:"vtc6",  name:"Sony/Murata Konion US18650VTC6",  format:"18650", mAh:3000, maxA:15, nomV:3.6, fullV:4.2, note:"Guter Allrounder." },
  { id:"ga",    name:"Panasonic NCR18650GA",            format:"18650", mAh:3450, maxA:10, nomV:3.6, fullV:4.2, note:"Hohe Kapazität, solide." },
  { id:"p28a",  name:"Molicel INR18650P28A",            format:"18650", mAh:2800, maxA:25, nomV:3.6, fullV:4.2, note:"Sehr stark (High Power)." },
  { id:"30t207", name:"Samsung INR20700-30T",           format:"20700", mAh:3000, maxA:35, nomV:3.6, fullV:4.2, note:"20700 High Power." },
  { id:"40t",   name:"Samsung INR21700-40T",            format:"21700", mAh:4000, maxA:35, nomV:3.6, fullV:4.2, note:"Sehr hochstromfähig." },
  { id:"50e",   name:"Samsung INR21700-50E",            format:"21700", mAh:5000, maxA:9.8, nomV:3.6, fullV:4.2, note:"Sehr hohe Kapazität." },
  { id:"p42a",  name:"Molicel INR21700P42A",            format:"21700", mAh:4200, maxA:30, nomV:3.6, fullV:4.2, note:"Top Allround (Power+Kapazität)." },
  { id:"p45b",  name:"Molicel INR21700P45B",            format:"21700", mAh:4500, maxA:45, nomV:3.6, fullV:4.2, note:"Sehr stark (High Power)." }
];

const CELL_DIAM_MM = { "18650": 18.3, "20700": 20.3, "21700": 21.3 };

const el = {
  pageCalc: document.getElementById("pageCalc"),
  pageLayout: document.getElementById("pageLayout"),

  cellModel: document.getElementById("cellModel"),
  format: document.getElementById("format"),
  capacity: document.getElementById("capacity"),
  maxA: document.getElementById("maxA"),
  nomV: document.getElementById("nomV"),
  fullV: document.getElementById("fullV"),
  cellNote: document.getElementById("cellNote"),

  series: document.getElementById("series"),
  parallel: document.getElementById("parallel"),
  cellInfo: document.getElementById("cellInfo"),
  packInfo: document.getElementById("packInfo"),

  packBtn: document.getElementById("packBtn"),
  packBtnFill: document.getElementById("packBtnFill"),
  packBtnPct: document.getElementById("packBtnPct"),
  packBtnState: document.getElementById("packBtnState"),
  packBtnText: document.getElementById("packBtnText"),

  backBtn: document.getElementById("backBtn"),
  topBtn: document.getElementById("topBtn"),
  bottomBtn: document.getElementById("bottomBtn"),

  nickelMm: document.getElementById("nickelMm"),
  gapMm: document.getElementById("gapMm"),

  exportSvgBtn: document.getElementById("exportSvgBtn"),
  cv: document.getElementById("cv"),

  threeBtn: document.getElementById("threeBtn"),
  threeWrap: document.getElementById("threeWrap"),
  threeContainer: document.getElementById("threeContainer"),
  threeClose: document.getElementById("threeClose"),
};

const state = { view:"top", isAnimating:false, flipPolarity:false };

const LIMIT_S_MAX = 12;
const LIMIT_P_MAX = 20;

function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }
function parseDigits(str){ return (str||"").replace(/[^\d]/g, ""); }

function parseSeries(str, fallback){
  const d = parseDigits(str);
  if(!d) return fallback;
  return clamp(parseInt(d,10), 1, LIMIT_S_MAX);
}
function parseParallel(str, fallback){
  const d = parseDigits(str);
  if(!d) return fallback;
  return clamp(parseInt(d,10), 1, LIMIT_P_MAX);
}

// iOS Fix: markieren + echte Ersetzung
function selectAllOnFocus(e){
  const t = e.target;
  setTimeout(()=>{ try{ t.focus(); t.setSelectionRange(0, t.value.length); }catch(_){} }, 0);
}
function clearOnFirstDigit(e){
  const t = e.target;
  if(t.dataset._cleared === "1") return;
  const allSelected = (t.selectionStart === 0 && t.selectionEnd === t.value.length);
  if(allSelected){
    t.value = "";
    t.dataset._cleared = "1";
  }
}

function fillDropdown(){
  for(const c of CELLS){
    const opt = document.createElement("option");
    opt.value = c.id;
    opt.textContent = c.name;
    el.cellModel.appendChild(opt);
  }
  el.cellModel.value = "s35e";
}
function getSelectedCell(){ return CELLS.find(c => c.id === el.cellModel.value) || CELLS[0]; }
function getCellDiamMm(){ const cell = getSelectedCell(); return CELL_DIAM_MM[cell.format] || 18.3; }

// Polung pro Spalte: 0 plus oben, 1 minus oben, 2 plus oben...
function isPlus(row, col){
  let plusTop = (col % 2 === 0);
  if (state.flipPolarity) plusTop = !plusTop;
  return state.view === "top" ? plusTop : !plusTop;
}

function syncPackInputs(){
  const s = parseSeries(el.series.value, 3);
  const p = parseParallel(el.parallel.value, 2);
  el.series.value = String(s);
  el.parallel.value = String(p);
  updateCalc();
  if(!el.pageLayout.classList.contains("hidden")) drawLayout();
}

function updateCalc(){
  const cell = getSelectedCell();
  const S = parseSeries(el.series.value, 3);
  const P = parseParallel(el.parallel.value, 2);

  el.series.value = String(S);
  el.parallel.value = String(P);

  el.format.value = cell.format;
  el.capacity.value = cell.mAh;
  el.maxA.value = cell.maxA;
  el.nomV.value = cell.nomV.toFixed(2);
  el.fullV.value = cell.fullV.toFixed(2);
  el.cellNote.textContent = cell.note || "";

  const storageV=3.80, cutoffRec=3.30, cutoffAbs=3.00;

  const packNomV=cell.nomV*S;
  const packFullV=cell.fullV*S;
  const packStorageV=storageV*S;
  const packCutRec=cutoffRec*S;
  const packCutAbs=cutoffAbs*S;

  const packAh=(cell.mAh/1000)*P;
  const packWh=packNomV*packAh;
  const packMaxA=cell.maxA*P;

  el.cellInfo.innerHTML=`
    <tr><td>Modell</td><td>${cell.name}</td></tr>
    <tr><td>Format</td><td>${cell.format}</td></tr>
    <tr><td>Nominal</td><td>${cell.nomV.toFixed(2)} V</td></tr>
    <tr><td>Voll</td><td>${cell.fullV.toFixed(2)} V</td></tr>
    <tr><td>Kapazität</td><td>${cell.mAh} mAh</td></tr>
    <tr><td>Max Dauerstrom</td><td>${cell.maxA} A</td></tr>
  `;

  el.packInfo.innerHTML=`
    <tr><td>Konfiguration</td><td>${S}S${P}P</td></tr>
    <tr><td>Zellen gesamt</td><td>${S*P}</td></tr>
    <tr><td>Nominalspannung</td><td>${packNomV.toFixed(2)} V</td></tr>
    <tr><td>Vollspannung</td><td>${packFullV.toFixed(2)} V</td></tr>
    <tr><td class="green">Lagerspannung</td><td class="green">${packStorageV.toFixed(2)} V</td></tr>
    <tr><td class="yellow">Entladen bis (empf.)</td><td class="yellow">${packCutRec.toFixed(2)} V</td></tr>
    <tr><td class="red">Untergrenze (absolut)</td><td class="red">${packCutAbs.toFixed(2)} V</td></tr>
    <tr><td>Kapazität</td><td>${packAh.toFixed(2)} Ah</td></tr>
    <tr><td>Energie</td><td>${packWh.toFixed(1)} Wh</td></tr>
    <tr><td>Max Dauerstrom</td><td>${packMaxA.toFixed(1)} A</td></tr>
  `;

  if(!state.isAnimating){
    el.packBtnFill.style.width = "0%";
    el.packBtnPct.textContent = "0%";
    el.packBtnState.textContent = "bereit";
    el.packBtnText.textContent = "Tippen zum Laden & Layout öffnen";
    el.packBtn.classList.remove("disabled");
  }
}

function showPage(which){
  if(which === "layout"){
    el.pageCalc.classList.add("hidden");
    el.pageLayout.classList.remove("hidden");
    window.scrollTo(0,0);
    resizeCanvas();
    drawLayout();
  } else {
    el.pageLayout.classList.add("hidden");
    el.pageCalc.classList.remove("hidden");
  }
}

function animateToLayout(){
  if(state.isAnimating) return;
  state.isAnimating = true;

  el.packBtn.classList.add("disabled");
  el.packBtnState.textContent = "lädt…";
  el.packBtnText.textContent = "Bitte warten";

  const duration = 900;
  const start = performance.now();

  function tick(now){
    const t = Math.min(1, (now - start) / duration);
    const pct = Math.round(t * 100);
    el.packBtnFill.style.width = pct + "%";
    el.packBtnPct.textContent = pct + "%";
    if(t < 1) requestAnimationFrame(tick);
    else{
      el.packBtnState.textContent = "fertig";
      el.packBtnText.textContent = "Layout wird geöffnet…";
      setTimeout(()=>{ state.isAnimating=false; showPage("layout"); }, 130);
    }
  }
  requestAnimationFrame(tick);
}

function roundRect(ctx, x, y, w, h, r){
  const min = Math.min(w,h);
  if(r > min/2) r = min/2;
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  ctx.closePath();
}

function resizeCanvas(){
  const cv = el.cv;
  const rect = cv.getBoundingClientRect();
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const maxH = Math.floor(window.innerHeight * 0.55);
  const targetH = Math.min(maxH, Math.floor(rect.width * 0.85));
  cv.width  = Math.floor(rect.width * dpr);
  cv.height = Math.floor(targetH * dpr);
}

window.addEventListener("resize", ()=>{
  if(!el.pageLayout.classList.contains("hidden")){
    resizeCanvas();
    drawLayout();
  }
});

function buildGeometryMm(){
  const S = parseSeries(el.series.value, 3);
  const P = parseParallel(el.parallel.value, 2);

  const d = getCellDiamMm();
  const r = d / 2;

  const gap = Math.max(0, Number(el.gapMm.value) || 0.6);
  const nickelW = Math.max(4, Number(el.nickelMm.value) || 8);

  const packW = S * d + (S - 1) * gap;
  const packH = P * d + (P - 1) * gap;

  function cellCenterMm(row, col){
    const x = r + col * (d + gap);
    const y = r + row * (d + gap);
    return {x,y};
  }

  const cells = [];
  for(let row=0; row<P; row++){
    for(let col=0; col<S; col++){
      const c = cellCenterMm(row,col);
      cells.push({row,col,x:c.x,y:c.y,r,plus:isPlus(row,col)});
    }
  }

  const parallelNickel = [];
  const seriesNickel = [];

  // Parallel (immer): 1 Strip pro Spalte über alle Reihen
  for(let col=0; col<S; col++){
    const top = cellCenterMm(0,col);
    const bot = cellCenterMm(P-1,col);
    const h = (bot.y - top.y) + d*0.85;
    parallelNickel.push({
      x: top.x - nickelW/2,
      y: top.y - d*0.42,
      w: nickelW,
      h: h,
      rad: nickelW*0.18
    });
  }

  // Series: gleiche Breite wie Parallel
  const lane = nickelW;

  function addRect(x,y,w,h,rad=0){ seriesNickel.push({x,y,w,h,rad}); }

  // ✅ Serien: pro Übergang UND pro Reihe eine horizontale Brücke (schweißbar 1:1)
  function addSeriesBridgeRowwise(col){
    const c0 = col, c1 = col + 1;

    const ref0 = cellCenterMm(0, c0);
    const ref1 = cellCenterMm(0, c1);
    const x = ref0.x - nickelW/2;
    const w = (ref1.x - ref0.x) + nickelW;

    for(let row=0; row<P; row++){
      const p0 = cellCenterMm(row, c0);
      addRect(x, p0.y - lane/2, w, lane, lane*0.20);
    }
  }

  // TOP: Übergänge 1,3,5...  |  BOTTOM: 0,2,4...
  function shouldDrawSeriesOnThisView(col){
    const seriesOnTop = (col % 2 === 1);
    return (state.view === "top" && seriesOnTop) || (state.view === "bottom" && !seriesOnTop);
  }

  if (S >= 2){
    for(let col=0; col<S-1; col++){
      if(!shouldDrawSeriesOnThisView(col)) continue;
      addSeriesBridgeRowwise(col);
    }
  }

  return {S,P,d,r,gap,nickelW,packW,packH,cells,parallelNickel,seriesNickel,lane};
}

function drawLayout(){
  const geo = buildGeometryMm();
  const cv = el.cv;
  const ctx = cv.getContext("2d");
  const w = cv.width, h = cv.height;

  ctx.clearRect(0,0,w,h);
  ctx.fillStyle="#0b0b0c";
  ctx.fillRect(0,0,w,h);

  const padPx = Math.max(18, Math.floor(w * 0.04));
  const availW = w - padPx*2;
  const availH = h - padPx*2;

  const pxPerMm = Math.min(availW/geo.packW, availH/geo.packH);
  const offX = padPx + (availW - geo.packW*pxPerMm)/2;
  const offY = padPx + (availH - geo.packH*pxPerMm)/2;

  const X = mm => offX + mm*pxPerMm;
  const Y = mm => offY + mm*pxPerMm;

  ctx.fillStyle="rgba(255,255,255,.90)";
  ctx.font=`${Math.floor(w*0.06)}px Arial`;
  ctx.textAlign="left";
  ctx.textBaseline="top";
  ctx.fillText(`${geo.S}S${geo.P}P — ${state.view.toUpperCase()} (Nickel)`, padPx, 10);

  // Parallel
  ctx.fillStyle="rgba(200,200,200,.28)";
  for(const p of geo.parallelNickel){
    roundRect(ctx, X(p.x), Y(p.y), p.w*pxPerMm, p.h*pxPerMm, Math.max(2, (p.rad||2)*pxPerMm));
    ctx.fill();
  }

  // Series
  ctx.fillStyle="rgba(235,235,235,.78)";
  ctx.beginPath();
  for(const s of geo.seriesNickel){
    const rad = (s.rad ?? (geo.lane*0.20)) * pxPerMm;
    const rx = X(s.x), ry = Y(s.y), rw = s.w*pxPerMm, rh = s.h*pxPerMm;
    const rr = Math.max(2, Math.min(rad, Math.min(rw,rh)/2));
    ctx.moveTo(rx+rr, ry);
    ctx.arcTo(rx+rw, ry, rx+rw, ry+rh, rr);
    ctx.arcTo(rx+rw, ry+rh, rx, ry+rh, rr);
    ctx.arcTo(rx, ry+rh, rx, ry, rr);
    ctx.arcTo(rx, ry, rx+rw, ry, rr);
    ctx.closePath();
  }
  ctx.fill();

  // Cells
  for(const c of geo.cells){
    const cx = X(c.x), cy = Y(c.y), rr = c.r*pxPerMm;

    ctx.fillStyle="rgba(124,92,255,.10)";
    ctx.beginPath(); ctx.arc(cx,cy,rr,0,Math.PI*2); ctx.fill();

    ctx.strokeStyle="rgba(255,255,255,.14)";
    ctx.lineWidth=Math.max(1, Math.floor(rr*0.10));
    ctx.beginPath(); ctx.arc(cx,cy,rr,0,Math.PI*2); ctx.stroke();

    ctx.fillStyle="rgba(255,255,255,.06)";
    ctx.beginPath(); ctx.arc(cx,cy,Math.floor(rr*0.55),0,Math.PI*2); ctx.fill();

    ctx.fillStyle=c.plus ? "rgba(255,255,255,.92)" : "rgba(255,255,255,.70)";
    ctx.font=`${Math.floor(rr*0.95)}px Arial`;
    ctx.textAlign="center";
    ctx.textBaseline="middle";
    ctx.fillText(c.plus?"+":"-", cx, cy);
  }
}

function exportSvgOneToOne(){
  const geo = buildGeometryMm();
  const title = `${geo.S}S${geo.P}P-${state.view}`;
  const W = geo.packW, H = geo.packH;

  const rects = (arr, fill, op) => arr.map(r =>
    `<rect x="${r.x.toFixed(3)}" y="${r.y.toFixed(3)}" width="${r.w.toFixed(3)}" height="${r.h.toFixed(3)}"
      rx="${((r.rad ?? (geo.lane*0.20))).toFixed(3)}" fill="${fill}" opacity="${op}"/>`
  ).join("");

  const circles = geo.cells.map(c =>
    `<circle cx="${c.x.toFixed(3)}" cy="${c.y.toFixed(3)}" r="${c.r.toFixed(3)}"
      fill="none" stroke="rgba(0,0,0,0.25)" stroke-width="0.3"/>`
  ).join("");

  const signs = geo.cells.map(c => {
    const t = c.plus ? "+" : "-";
    return `<text x="${c.x.toFixed(3)}" y="${(c.y+0.4).toFixed(3)}"
      font-size="${(geo.d*0.35).toFixed(3)}" text-anchor="middle" fill="rgba(0,0,0,0.85)">${t}</text>`;
  }).join("");

  const svg =
`<svg xmlns="http://www.w3.org/2000/svg" width="${W}mm" height="${H}mm" viewBox="0 0 ${W} ${H}">
  <rect x="0" y="0" width="${W}" height="${H}" fill="#ffffff"/>
  ${rects(geo.parallelNickel, "#b7b7b7", "0.55")}
  ${rects(geo.seriesNickel, "#9e9e9e", "0.85")}
  ${circles}
  ${signs}
</svg>`;

  const blob = new Blob([svg], {type:"image/svg+xml"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `${title}-1to1.svg`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

let three = { renderer:null, scene:null, camera:null, controls:null, anim:null };

function open3D(){
  el.threeWrap.classList.remove("hidden");
  el.threeContainer.innerHTML = "";

  const geo = buildGeometryMm();
  const width = el.threeContainer.clientWidth;
  const height = el.threeContainer.clientHeight;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b0b0c);

  const camera = new THREE.PerspectiveCamera(45, width/height, 0.1, 5000);
  camera.position.set(0, 140, 240);

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(width, height);
  el.threeContainer.appendChild(renderer.domElement);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  scene.add(new THREE.AmbientLight(0xffffff, 0.7));
  const dir = new THREE.DirectionalLight(0xffffff, 0.8);
  dir.position.set(200, 300, 200);
  scene.add(dir);

  const cx = geo.packW/2, cy = geo.packH/2;

  const cellMat = new THREE.MeshStandardMaterial({color:0x2a7f55, metalness:0.1, roughness:0.7});
  const capMatP = new THREE.MeshStandardMaterial({color:0xe6e6e6, metalness:0.6, roughness:0.25});
  const capMatN = new THREE.MeshStandardMaterial({color:0x888888, metalness:0.6, roughness:0.25});

  for(const c of geo.cells){
    const cylGeo = new THREE.CylinderGeometry(c.r, c.r, geo.d, 40);
    const cyl = new THREE.Mesh(cylGeo, cellMat);
    cyl.rotation.z = Math.PI/2;
    cyl.position.set((c.x - cx), 0, (c.y - cy));
    scene.add(cyl);

    const diskGeo = new THREE.CylinderGeometry(c.r*0.55, c.r*0.55, 0.8, 32);
    const disk = new THREE.Mesh(diskGeo, c.plus ? capMatP : capMatN);
    disk.rotation.z = Math.PI/2;
    disk.position.set((c.x - cx) + (geo.d/2), 0.6, (c.y - cy));
    scene.add(disk);
  }

  const nickelMat = new THREE.MeshStandardMaterial({color:0xbdbdbd, metalness:0.7, roughness:0.25});
  function addPlate(r, y){
    const g = new THREE.BoxGeometry(r.w, 0.8, r.h);
    const m = new THREE.Mesh(g, nickelMat);
    m.position.set((r.x + r.w/2 - cx), y, (r.y + r.h/2 - cy));
    scene.add(m);
  }

  for(const r of geo.parallelNickel) addPlate(r, 1.2);
  for(const r of geo.seriesNickel) addPlate(r, 2.2);

  function anim(){
    three.anim = requestAnimationFrame(anim);
    controls.update();
    renderer.render(scene, camera);
  }
  anim();

  three = { renderer, scene, camera, controls, anim: three.anim };
}

function close3D(){
  el.threeWrap.classList.add("hidden");
  if(three.anim) cancelAnimationFrame(three.anim);
  try{ three.renderer?.dispose?.(); }catch(e){}
  el.threeContainer.innerHTML = "";
  three = { renderer:null, scene:null, camera:null, controls:null, anim:null };
}

// Events
el.packBtn.addEventListener("click", animateToLayout);

el.backBtn.addEventListener("click", ()=>{
  state.isAnimating = false;
  el.packBtnFill.style.width="0%";
  el.packBtnPct.textContent="0%";
  el.packBtnState.textContent="bereit";
  el.packBtnText.textContent="Tippen zum Laden & Layout öffnen";
  el.packBtn.classList.remove("disabled");
  showPage("calc");
});

el.topBtn.addEventListener("click", ()=>{
  state.view="top";
  el.topBtn.classList.add("primary");
  el.bottomBtn.classList.remove("primary");
  drawLayout();
});
el.bottomBtn.addEventListener("click", ()=>{
  state.view="bottom";
  el.bottomBtn.classList.add("primary");
  el.topBtn.classList.remove("primary");
  drawLayout();
});

el.cellModel.addEventListener("change", syncPackInputs);

["focus","click"].forEach(evt=>{
  el.series.addEventListener(evt, selectAllOnFocus);
  el.parallel.addEventListener(evt, selectAllOnFocus);
});
el.series.addEventListener("keydown", clearOnFirstDigit);
el.parallel.addEventListener("keydown", clearOnFirstDigit);

["input","change","blur"].forEach(evt=>{
  el.series.addEventListener(evt, ()=>{ el.series.dataset._cleared="0"; syncPackInputs(); });
  el.parallel.addEventListener(evt, ()=>{ el.parallel.dataset._cleared="0"; syncPackInputs(); });
});

el.nickelMm.addEventListener("input", drawLayout);
el.gapMm.addEventListener("input", drawLayout);

el.exportSvgBtn.addEventListener("click", exportSvgOneToOne);

el.threeBtn.addEventListener("click", open3D);
el.threeClose.addEventListener("click", close3D);

fillDropdown();
updateCalc();
</script>
</body>
</html>
